---
title: "2022最新前端面试题整理"
date: 2022-06-06T17:09:23+08:00
---


## HTML

### 如何理解 HTML 语义化？

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

### script 标签中 defer 和 async 的区别？

- script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- defer script：完全不会阻碍 HTML

推荐文章 [图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

## CSS

### 盒模型介绍

CSS3 中的盒模型有以下两种：标准盒模型、IE（替代）盒模型。

两种盒子模型都是由 content + padding + border + margin 构成，其大小都是由 content + padding + border 决定的，但是盒子内容宽/高度（即 width/height）的计算范围根据盒模型的不同会有所不同：

- 标准盒模型：只包含 content 。
- IE（替代）盒模型：content + padding + border 。

可以通过 box-sizing 来改变元素的盒模型：

- box-sizing: content-box ：标准盒模型（默认值）。
- box-sizing: border-box ：IE（替代）盒模型。

### 介绍下 BFC 及其应用

BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到**尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸**等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做视觉格式化模型的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，**用于决定块级盒的布局及浮动相互影响范围的一个区域。**
BFC 具有一些特性：

- 块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。
- 在 BFC 中上下相邻的两个容器的 `margin` 会重叠，创建新的 BFC 可以避免外边距重叠。
- 计算 BFC 的高度时，需要计算浮动元素的高度。
- BFC 区域不会与浮动的容器发生重叠。
- BFC 是独立的容器，容器内部元素不会影响外部元素。
- 每个元素的左 `margin` 值和容器的左 `border` 相接触。

利用这些特性，我们可以解决以下问题：

- 利用 4  和 6 ，我们可以实现三栏（或两栏）自适应布局。
- 利用 2 ，我们可以避免 `margin` 重叠问题。
- 利用 3 ，我们可以避免高度塌陷。

创建 BFC 的方式：

- 绝对定位元素（`position` 为 `absolute` 或 `fixed` ）。
- 行内块元素，即 `display` 为 `inline-block` 。
- `overflow` 的值不为 `visible` 。

### 怎么让一个 div 水平垂直居中

### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

### 介绍下 BFC、IFC、GFC 和 FFC

### css 如何实现左侧固定 200px，右侧自适应的布局（两栏布局）

现有以下DOM结构

```html
<div class="outer">
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```

1. 利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 margin-left 设为固定宽度 。注意，因为右边元素的 width 默认为 auto ，所以会自动撑满父元素。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：浮动+margin-lefts](https://codepen.io/afishtail/pen/jOZJPKJ)

2. 同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 overflow: hidden; 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：浮动+BFC](https://codepen.io/afishtail/pen/jOZJPKJ)

3. 利用 flex 布局，左边元素固定宽度，右边的元素设置 flex: 1 。

```css
.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：flex](https://codepen.io/afishtail/pen/PoQLqVB)
4. grid
5. 绝对定位

### 实现圣杯布局和双飞翼布局（经典三分栏布局）

- grid

``` html
<!-- html -->
<div class="grid-box">
  <div class="grid-item header">
    <div>header</div>
  </div>
  <div class="grid-item left">
    <div>left</div>
  </div>
  <div class="grid-item content">
    <div>content</div>
  </div>
  <div class="grid-item right">
    <div>right</div>
  </div>
  <div class="grid-item footer">
    <div>footer</div>
  </div>
</div>

<!-- css -->
// 第一种 使用grid-template-areas定义
<style>
  .grid-box {
    display: grid;
    grid-template-columns: 200px 1fr 200px;
    grid-auto-rows: 80px 1fr 100px;
    height: 480px;
    border: 1px solid;
    // width: 240px;
    /* 自定义布局格式 */
    grid-template-areas:
      'header header header'
      'left content right'
      'footer footer footer';
  }
  .grid-item {
    border: 1px solid;
    background-color: goldenrod;
  }
  .header {
    /* 使用grid最外层定义的名称 */
    grid-area: header;
    background-color: skyblue;
  }
  .footer {
    background-color: aqua;
    grid-area: footer;
  }
</style>


// 第二种 直接使用数字进行划分
<style>
.grid-box {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
  grid-auto-rows: 80px 1fr 100px;
  height: 480px;
  border: 1px solid;

  .grid-item {
    border: 1px solid;
    background-color: goldenrod;
  }
  .header {
    /* 使用 数字+/ 划分区域 */
    grid-area: 1/1/1/4;
    background-color: skyblue;
  }
  .footer {
    background-color: aqua;
    grid-area: 3/1/3/4;
  }
}
</style>
```

[Grid实现经典双飞翼布局](https://codepen.io/afishtail/pen/oNEVXRe)

- flex
- float + margin负值（感觉代码很繁琐）

### 伪类与伪元素有什么区别

### css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分

### CSS 如何设置一行超出显示省略号

### CSS 如何设置多行超出显示省略号

## JavaScript

### 手写深拷贝

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */

function deepClone(obj = {}, map = new Map()) {
  if (typeof obj !== "object") {
    return obj;
  }
  if (map.get(obj)) {
    return map.get(obj);
  }

  let result = {};
  // 初始化返回结果
  if (
    obj instanceof Array ||
    // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
    Object.prototype.toString(obj) === "[object Array]"
  ) {
    result = [];
  }
  // 防止循环引用
  map.set(obj, result);
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map);
    }
  }

  // 返回结果
  return result;
}
```

### 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？

> 推荐阅读：[硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准](https://juejin.cn/post/6940405970954616839),[0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？](https://juejin.cn/post/6844903680362151950)

原因总结:

- 进制转换 ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。
- 对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。

解决办法：

- 大数运算
- `Number.EPSILON`误差范围

```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

- 转成字符串，对字符串做加法运算。

```js
// 字符串数字相加
var addStrings = function (num1, num2) {
  let i = num1.length - 1;
  let j = num2.length - 1;
  const res = [];
  let carry = 0;
  while (i >= 0 || j >= 0) {
    const n1 = i >= 0 ? Number(num1[i]) : 0;
    const n2 = j >= 0 ? Number(num2[j]) : 0;
    const sum = n1 + n2 + carry;
    res.unshift(sum % 10);
    carry = Math.floor(sum / 10);
    i--;
    j--;
  }
  if (carry) {
    res.unshift(carry);
  }
  return res.join("");
};

function isEqual(a, b, sum) {
  const [intStr1, deciStr1] = a.toString().split(".");
  const [intStr2, deciStr2] = b.toString().split(".");
  const inteSum = addStrings(intStr1, intStr2); // 获取整数相加部分
  const deciSum = addStrings(deciStr1, deciStr2); // 获取小数相加部分
  return inteSum + "." + deciSum === String(sum);
}

console.log(isEqual(0.1, 0.2, 0.3)); // true
```

这是 leetcode 上一道原题：[415. 字符串相加](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-strings%2F)。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。

### 基本的数据类型介绍，及值类型和引用类型的理解

### JS进阶概念

- 原型和原型连
- 作用域与作用域链
- 执行上下文
- 闭包
- 垃圾回收

### call、apply、bind实现

```js
Function.prototype.myCall = function (context) {
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  context.fn = this
  const args = [...arguments].slice(1)
  const res = context.fn(...args)
  delete context.fn
  return res
}

Function.prototype.myApply = function (context) {
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}

//TODO： bind手写较难
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
      throw new TypeError('Error')
  }
  //返回一个绑定this的函数，这里我们需要保存this
  const _this = this
  const args = [...arguments].slice(1)
      //返回一个函数
  return function F() {
      //因为返回一个函数，我们可以new F()需要判断能当做构造函数吗
      if (this instanceof F) {
          return new _this(...args, ...arguments)
      }
      return _this.apply(context, args.concat(...arguments))
  }
}
```

### new实现

```js
function myNew(context) {
  const obj = new Object()
  obj.__proto__ = context.prototype
  const res = context.apply(obj, [...arguments].slice(1))
  return typeof res === 'object' ? res: obj
}
```

### 模拟实现一个 Promise.finally

### 模拟实现一个 Promise.all

```js
Promise.all = function (promises) {
  return new Promise((resolve, reject) => {
    // 参数可以不是数组，但必须具有 Iterator 接口
    if (typeof promises[Symbol.iterator] !== "function") {
      reject("Type error");
    }
    if (promises.length === 0) {
      resolve([]);
    } else {
      const res = [];
      let count = 0;
      const len = promises.length;
      for (let i = 0; i < len; i++) {
        //考虑到 promises[i] 可能是 thenable 对象也可能是普通值
        Promise.resolve(promises[i])
          .then((data) => {
            res[i] = data;
            if (++count === len) {
              resolve(res);
            }
          })
          .catch((err) => {
            reject(err);
          });
      }
    }
  });
};
```

### 实现一个 EventMitter 类

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  // 实现订阅
  on(type, callBack) {
    if (!this.events[type]) {
      this.events[type] = [callBack];
    } else {
      this.events[type].push(callBack);
    }
  }
  // 删除订阅
  off(type, callBack) {
    if (!this.events[type]) return;
    this.events[type] = this.events[type].filter((item) => {
      return item !== callBack;
    });
  }
  // 只执行一次订阅事件
  once(type, callBack) {
    function fn() {
      callBack();
      this.off(type, fn);
    }
    this.on(type, fn);
  }
  // 触发事件
  emit(type, ...rest) {
    this.events[type] &&
      this.events[type].forEach((fn) => fn.apply(this, rest));
  }
}
```

### JS 异步解决方案的发展历程以及优缺点

### 异步笔试题，请写出下面代码的运行结果

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

### 模拟实现一个 Promise.race

```js
Promise._race = promises => new Promise((resolve, reject) => {
 promises.forEach(promise => {
  promise.then(resolve, reject)
 })
})

// 兼容非promise
const _race = (p)=>{
 return new Promise((resolve, reject)=>{
  p.forEach((item)=>{
   Promise.resolve(item).then(resolve, reject)
  })
 })
}
```

## Vue

### 谈一下Vue响应式原理

- 怎么进行依赖收集的？
  在`getter`中收集依赖，getter在  时候触发。

### vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进

### react 与 vue 数组中 key 的作用是什么

diff 算法需要比对虚拟 dom 的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode 会首先判断 key 和标签名是否一致，如果一致再去判断子节点一致，使用 key 可以帮助 diff 算法提升判断的速度，在页面重新渲染时更快消耗更少

### vue 中 computed 的原理是什么

### vue 中 v-if 和 v-show 的区别是什么

### Vue 中 nextTick 的实现原理是什么

### 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？

**（1）hash 模式的实现原理**
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：
<https://www.word.com#search>
复制代码hash  路由模式的实现主要是基于下面几个特性：

- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

**（2）history 模式的实现原理**
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
复制代码history 路由模式的实现主要基于存在下面几个特性：

- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
- 我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

### 谈谈你对 keep-alive 的了解？

### Vue 组件间通信有哪几种方式？

vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信

### Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法

### 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？

- 这是因为devtool工具会记录mutation的日记;
- 每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照;
- 但是在mutation中执行异步操作，就无法追踪到数据的变化;
- 所以Vuex的重要原则中要求 mutation必须是同步函数;

### 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

### vue 渲染大量数据时应该怎么优化？

### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？

### vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法

### v-if、v-show、v-html 的原理是什么，它是如何封装的？

## React

### redux 为什么要把 reducer 设计成纯函数

### react-router 里的 <Link> 标签和 <a> 标签有什么区别

### 了解 React 中的 ErrorBoundary 吗，它有那些使用场景

### 有没有使用过 react hooks，它带来了那些便利

### 如何使用 react hooks 实现一个计数器的组件

### React 中，cloneElement 与 createElement 各是什么，有什么区别

### React Portal 有哪些使用场景

### 什么是 virtual DOM，它的引入带了什么好处

### React 中 fiber 是用来做什么的

关于这块儿我觉得可以好好阅读下这篇无敌的博客了：[Build your own React](https://link.juejin.cn/?target=https%3A%2F%2Fpomb.us%2Fbuild-your-own-react%2F)。
它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。
然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章：
[这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.cn/post/6844903975112671239)

### React hooks 中 useCallback 的使用场景是什么

### useEffect 中如何使用 async/await

### 为什么不能在表达式里面定义 react hooks

推荐这篇文章：[我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁](我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁)。

hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。

### 关于 React hooks 的 caputre value，以下输出多少

### 在 redux 中如何发送请求

### 在 redux 中如何写一个记录状态变更的日志插件

### React 在 setState 时发生了什么

### React.setState 是同步还是异步的

`setState` 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。
同步还是异步取决于它被调用的环境。

- 如果 `setState` 在 React 能够控制的范围被调用，它就是异步的。比如合成事件处理函数，生命周期函数， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。
- 如果 `setState` 在原生 JavaScript 控制的范围被调用，它就是同步的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 `setState` 被调用后会立即更新 DOM 。

### React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的

### 在 React 中如何实现代码分割 (code splitting

### 在 React 中如何做好性能优化

### 当多次重复点击按钮时，以下三个 Heading 是如何渲染的

### React 中什么是合成事件

### React 中监听 input 的 onChange 事件的原生事件是什么

### React.memo 中是如何实现性能优化的

### useLayoutEffect 和 useEffect 有什么区别

对于 React 的函数组件来说，其更新过程大致分为以下步骤：

1. 因为某个事件 state 发生变化。
2. React 内部更新 state 变量。
3. React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。
4. 将更新过后的 DOM 数据绘制到浏览器中。
5. 用户看到新的页面。

useEffect 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。
useLayoutEffect 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。

### React 事件机制，React 16 和 React 17 事件机制的不同

阅读这篇文章即可：[一文吃透 react 事件系统原理](https://juejin.cn/post/6955636911214067720)。

为什么要自定义事件机制？

抹平浏览器差异，实现更好的跨平台。
避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。
方便事件统一管理和事务机制。

### HOC 和 hook 的区别

hoc 能复用逻辑和视图，hook 只能复用逻辑。

### useEffect 依赖为空数组与 componentDidMount 区别

在 `render` 执行之后，`componentDidMount` 会执行，如果在这个生命周期中再一次 `setState` ，会导致再次 `render` ，返回了新的值，浏览器只会渲染第二次 `render` 返回的值，这样可以避免闪屏。
但是 `useEffect` 是在真实的 `DOM` 渲染之后才会去执行，这会造成两次 `render` ，有可能会闪屏。
实际上 `useLayoutEffect` 会更接近 `componentDidMount` 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。

### React.memo() 和 React.useMemo() 的区别

- `memo` 是一个高阶组件，默认情况下会对 `props` 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。
- `useMemo` 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，`useMemo` 是在 `render` 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。

### React.useCallback() 和 React.useMemo() 的区别

- `useCallback` 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。
- `useMemo` 可缓存值。

有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。

### React.forwardRef 是什么及其作用

这里还是阅读官方文档来的清晰：[React.forwardRef](https://link.juejin.cn/?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-api.html%23reactforwardref)。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。

### React性能优化手段

推荐文章：[React 性能优化的 8 种方式了解一下？](https://juejin.cn/post/6844903924302888973)

- 使用 React.memo 来缓存组件。
- 使用 React.useMemo 缓存大量的计算。
- 避免使用匿名函数。
- 利用 React.lazy 和 React.Suspense 延迟加载不是立即需要的组件。
- 尽量使用 CSS 而不是强制加载和卸载组件。
- 使用 React.Fragment 避免添加额外的 DOM。

### React Redux

[Redux 包教包会（一）：介绍 Redux 三大核心概念](https://juejin.cn/post/6844904021187117069)

## NodeJs

### 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?

在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：

```js
(function(exports, require, module, __filename, __dirname) {
// 模块的代码实际上在这里
});
```

通过这样做，Node 实现了以下几点：

- 保持了顶层变量作用在模块范围内，而不是全局对象
- 有助于提供一些看似全局实际是特定模块的变量：
  - 导出的 `module` 和 `exports`对象
  - 包含模块绝对文件名和目录路径的便捷变量`__filename`和`__dirname`

### a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?

### 说一下NodeJs中的错误处理？

处理错误，最常用的就是try catch 了。可是 try catch无法捕获异步错误。Node.js中，异步操作是十分常见的，异步操作主要是在回调函数中暴露错误。看一个例子：

```js
const readFile = function(path) {
 return new Promise((resolve,reject) => {
  fs.readFile(path, (err, data) => {
   if(err) { 
    throw err; // catch无法捕获错误，这和Node的eventloop有关。
        // reject(err); // catch可以捕获
      }
      resolve(data);
  });
 });
}

router.get('/xxx', async function(req, res) {
  try {
    const res = await readFile('xxx');
    ...
  } catch (e){
    // 捕获错误处理
    ...
    res.send(500);
  }
});
```

上面的代码中，readFile 中 throw 出来的错误，是无法被catch捕获的。如果我们把 throw err 换成 Promise.reject(err)，catch中是可以捕获到错误的。
**我们可以把异步操作都Promise化，然后统一使用 async 、try、catch 来处理错误。**
但是，总会有地方会被遗漏。这个时候，可以使用process来捕获全局错误，防止进程直接退出，导致后面的请求挂掉。示例代码：

```js
process.on('uncaughtException', (err) => {
  console.error(`${err.message}\n${err.stack}`);
});

process.on('unhandledRejection', (reason, p) => {
  console.error(`Unhandled Rejection at: Promise ${p} reason: `, reason);
});

```

### Eventemitter 的 emit 是同步还是异步?

**EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。**

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', () => {
  console.log('hi 1');
});
emitter.on('myEvent', () => {
  console.log('hi 2');
});
emitter.emit('myEvent');
// hi 1
// hi 2
```

如下函数会不会死循环？

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', function sth () {
  emitter.on('myEvent', sth);
  console.log('hi');
});
emitter.emit('myEvent');
// hi
```

不会，只打印一遍hi

### 谈Node中的事件循环及其和浏览器中事件循环的区别？

[掘金：浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.cn/post/6844903761949753352)

### 以下代码，koa 会返回什么数据

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
  wait next()
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 2
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  wait next()
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

### Node如何进行进程间通信？

- 原生IPC通道

```js
// parent.js
const cp = require('child_process');
const n = cp.fork(`child.js`);

n.on('message', (m) => {
  console.log('父进程收到消息', m);
});

// 使子进程输出: 子进程收到消息 { hello: 'world' }
n.send({ hello: 'world' });

// child.js
process.on('message', (m) => {
  console.log('子进程收到消息', m);
});

// 使父进程输出: 父进程收到消息 { foo: 'bar', baz: null }
process.send({ foo: 'bar', baz: NaN });
```

运行：

```code
> node parent.js
子进程收到消息 { hello: 'world' }
父进程收到消息 { foo: 'bar', baz: null }
```

- 通过 sockets
- 消息队列

> 参考：[Node 进程间怎么通信的](https://www.cnblogs.com/everlose/p/12846737.html)

### Node 中 require 时发生了什么？

参考：[详解Node模块加载机制]<https://blog.csdn.net/ayqy_jiajie/article/details/106654770>

### 简述 node/v8 中的垃圾回收机制

### node 中 exec，fork 与 spawn 有何区别？

这四个都可以用来创建子进程

1.spawn和fork都是返回一个基于流的子进程对象

2.exec和execFile可以在回调中拿到返回的buffer的内容（执行成功或失败的输出）

3.exec是创建子shell去执行命令，用来直接执行shell命令  。execFile是去创建任意你指定的文件的进程

4.fork是一种特殊的spawn，可以理解为spawn增强版，返回的子进程对象可以和父进程对象进行通信，通过send和on方法。
> 参考
[Node官网](http://nodejs.cn/api/child_process.html#child_processspawncommand-args-options)

### node 中 dns.resolve 及 dns.lookup 有什么区别

### Node 中 require json 文件数据时，如何当文件更新时，重新 require

```js
function requireUncached(module) {
  delete require.cache[require.resolve(module)];
  return require(module);
}
```

### 在 node 中如何开启 https

```js
import path from "path";
import fs from "fs";
import express from "express";
import http from "http";
import https from "https";

const app = express();

const cred = {
  key: fs.readFileSync(path.resolve(__dirname, "../key.pem")),
  cert: fs.readFileSync(path.resolve(__dirname, "../cert.pem")),
};
const httpServer = http.createServer(app);
const httpsServer = https.createServer(cred, app);

httpServer.listen(8000);
httpsServer.listen(8888);
```

### node 中 module.exports 与 exports 有什么区别

### 在 node 中如何判断一个对象是 stream

`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。

每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`。
代码如下，摘自 is-stream (opens new window): 一个周下载量两千万的 npm package。

```js
const isStream = (stream) =>
  stream !== null &&
  typeof stream === "object" &&
  typeof stream.pipe === "function";

isStream.writable = (stream) =>
  isStream(stream) &&
  stream.writable !== false &&
  typeof stream._write === "function" &&
  typeof stream._writableState === "object";

isStream.readable = (stream) =>
  isStream(stream) &&
  stream.readable !== false &&
  typeof stream._read === "function" &&
  typeof stream._readableState === "object";

isStream.duplex = (stream) =>
  isStream.writable(stream) && isStream.readable(stream);

isStream.transform = (stream) =>
  isStream.duplex(stream) &&
  typeof stream._transform === "function" &&
  typeof stream._transformState === "object";
```

### express 中间件的原理是什么?

一个管道，每一个中间件都是handler，经过每一步处理，最终结束。

### 简述 koa 的中间件原理，手写 koa-compose 代码

```js
function compose(middlewares) {
  return (ctx) => {
    const dispatch = (i) => {
      const middleware = middlewares[i];
      if (i === middlewares.length) {
        return;
      }
      return middleware(ctx, () => dispatch(i + 1));
    };
    return dispatch(0);
  };
}
```

### koa与express的区别？

[glory-Koa与Express的区别](https://zhuanlan.zhihu.com/p/353109449)
[进军的蜗牛-express和koa的区别](https://www.cnblogs.com/yalong/p/15566133.html)

### koa的中间件怎么传递消息？

参数挂到 ctx上

### 在 Node 中流 (stream) 分为几类，有哪些应用场景

Node.js 中有四种基本的流类型：

- Writable: 可以写入数据的流（例如，fs.createWriteStream()）。

- Readable: 可以从中读取数据的流（例如，fs.createReadStream()）。

- Duplex: Readable 和 Writable 的流（例如，net.Socket）。

- Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，zlib.createDeflate()）

### node和客户端怎么解决跨域的问题？

### ESModule 和 CommonJs区别是什么？

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## TypeScript

### 什么是类型保护

- typeof
- 平等缩小(比如===、!==)
- instanceof
- in

### interface和type区别

- 如果是定义**非对象类型**，通常推荐使用type，比如Direction、Alignment、一些Function;
- 如果是定义**对象类型**，那么他们是有区别的:
  - interface 可以重复的对某个接口来定义属性和方法;
  - 而type定义的是别名，别名是不能重复的;

## 网络

### 简单讲解一下http2的多路复用

### 谈谈你对TCP三次握手和四次挥手的理解

### 介绍 HTTPS 握手过程

### HTTPS 握手过程中，客户端如何验证证书的合法性

### 介绍下 HTTPS 中间人攻击

### 介绍下 http1.0、1.1、2.0 协议的区别？

### 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

### 为什么 HTTP1.1 不能实现多路复用（腾讯）

### 介绍下Options请求

## 浏览器

### 从浏览器地址栏输入 url 到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
强缓存。
协商缓存。
2. DNS 域名解析。（字节面试被虐后，是时候搞懂 DNS 了）
3. TCP 连接。

  >总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

4. http 请求。
5. 服务器处理请求并返回 HTTP 报文。
6. 浏览器渲染页面。
推荐阅读：

- [从 URL 输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)
- [从输入 URL 开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)
- [字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)

### 说说浏览器和 Node 事件循环的区别

### 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

### cookie 和 token 都存放在 header 中，为什么不会劫持 token？

### 浏览器缓存读取规则

### 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

### 介绍下如何实现 token 加密

### 介绍下常见的web攻击方式

### 网站开发中，如何实现图片的懒加载

### prefetch 与 preload 的区别是什么

### 简单介绍 requestIdleCallback 及使用场景

### 如何找到当前页面出现次数最多的 HTML 标签

### 浏览器的剪切板中如何监听复制事件

### JSONP 的原理是什么，如何实现

### 如何实现页面文本不可复制

### 异步加载 JS 脚本时，async 与 defer 有何区别

### load 事件与 DomContentLoaded 事件的先后顺序

### React/Vue 中的 router 实现原理如何

### 什么是事件委托，e.currentTarget 与 e.target 有何区别

### SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的

### 简述下 WebWorker，它如何进行通信

### 浏览器中监听事件函数 addEventListener 第三个参数有那些值

### 浏览器中 Frame 与 Event Loop 的关系是什么

### 浏览器中如何使用原生的 ESM

## 设计模式

### 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

## 工程化

> 推荐阅读

- [原理初探：当面试官问 Webpack 的时候他想知道什么](https://juejin.cn/post/6943468761575849992)
- [简易实现：面试官：webpack 原理都不会，手写一个 webpack，看看 AST 怎么用](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039231950)
- [加料：简单易懂的 webpack 打包后 JS 的运行过程，Webpack 手写 loader 和 plugin](https://juejin.cn/post/6888936770692448270)
- [热更新原理：Webpack HMR 原理解析](https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F30669007)
- [面试题：「吐血整理」再来一打 Webpack 面试题](https://juejin.cn/post/6844904094281236487)

### 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？

### 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

### webpack 打包 vue 速度太慢怎么办？

### webpack 中 loader 和 plugin 的区别是什么（平安）

### babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？

### 使用 webpack 时如何优化项目体积

### Tree Shaking 的原理是什么

### vue-loader 的实现原理是什么

### 对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？

### Code Splitting 的原理是什么

### 使用 webpack 如何分包

### 如何压缩前端项目中 JS 的体积

### webpack 的 runtime 做了什么事情

### webpack 中的 code spliting 是如何动态加载 chunk 的？

### 打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中

### 打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源

### 打包器(webpack/rollup) 如何加载 style 样式资源

### 如何提升 webpack 构建资源的速度

### 如何分析前端打包体积

### peerDependency 是为了解决什么问题

### 前端打包时 cjs、es、umd 模块有何不同

### sourceMap的最佳实践？

- 开发阶段:推荐使用 source-map或者cheap-module-source-map。这分别是vue和react使用的值，可以获取调试信息，方便快速开发;
- 测试阶段:推荐使用 source-map或者cheap-module-source-map。测试阶段我们也希望在浏览器下看到正确的错误提示;
- 发布阶段:false、缺省值(不写)
