---
title: "2022最新前端面试题整理"
date: 2022-06-06T17:09:23+08:00
---


## HTML

### 如何理解 HTML 语义化？

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

### script 标签中 defer 和 async 的区别？

- script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- defer script：完全不会阻碍 HTML

推荐文章 [图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

## CSS

### 盒模型介绍

CSS3 中的盒模型有以下两种：标准盒模型、IE（替代）盒模型。

两种盒子模型都是由 content + padding + border + margin 构成，其大小都是由 content + padding + border 决定的，但是盒子内容宽/高度（即 width/height）的计算范围根据盒模型的不同会有所不同：

- 标准盒模型：只包含 content 。
- IE（替代）盒模型：content + padding + border 。

可以通过 box-sizing 来改变元素的盒模型：

- box-sizing: content-box ：标准盒模型（默认值）。
- box-sizing: border-box ：IE（替代）盒模型。

### 介绍下 BFC 及其应用

### 怎么让一个 div 水平垂直居中

### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

### 介绍下 BFC、IFC、GFC 和 FFC

### css 如何实现左侧固定 300px，右侧自适应的布局

### 如何实现左右固定，中间自适应布局

### 伪类与伪元素有什么区别

### css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分

### CSS 如何设置一行超出显示省略号

### CSS 如何设置多行超出显示省略号

## JavaScript

### JS 异步解决方案的发展历程以及优缺点

### 模拟实现一个 Promise.finally

### 模拟实现一个 Promise.all

### 异步笔试题，请写出下面代码的运行结果

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

### 模拟实现一个 Promise.race

```js
Promise._race = promises => new Promise((resolve, reject) => {
 promises.forEach(promise => {
  promise.then(resolve, reject)
 })
})

// 兼容非promise
const _race = (p)=>{
 return new Promise((resolve, reject)=>{
  p.forEach((item)=>{
   Promise.resolve(item).then(resolve, reject)
  })
 })
}
```

## Vue

### 谈一下Vue响应式原理

- 怎么进行依赖收集的？
  在`getter`中收集依赖，getter在  时候触发。

### vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进

### react 与 vue 数组中 key 的作用是什么

diff 算法需要比对虚拟 dom 的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode 会首先判断 key 和标签名是否一致，如果一致再去判断子节点一致，使用 key 可以帮助 diff 算法提升判断的速度，在页面重新渲染时更快消耗更少

### vue 中 computed 的原理是什么

### vue 中 v-if 和 v-show 的区别是什么

### Vue 中 nextTick 的实现原理是什么

### 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？

**（1）hash 模式的实现原理**
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：
<https://www.word.com#search>
复制代码hash  路由模式的实现主要是基于下面几个特性：

- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

**（2）history 模式的实现原理**
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
复制代码history 路由模式的实现主要基于存在下面几个特性：

- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
- 我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

### 谈谈你对 keep-alive 的了解？

### Vue 组件间通信有哪几种方式？

vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信

### Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法

### 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？

### 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

### vue 渲染大量数据时应该怎么优化？

### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？

### vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法

### v-if、v-show、v-html 的原理是什么，它是如何封装的？

## React

### redux 为什么要把 reducer 设计成纯函数

### react-router 里的 <Link> 标签和 <a> 标签有什么区别

### 了解 React 中的 ErrorBoundary 吗，它有那些使用场景

### 有没有使用过 react hooks，它带来了那些便利

### 如何使用 react hooks 实现一个计数器的组件

### React 中，cloneElement 与 createElement 各是什么，有什么区别

### React Portal 有哪些使用场景

### 什么是 virtual DOM，它的引入带了什么好处

### React 中 fiber 是用来做什么的

### React hooks 中 useCallback 的使用场景是什么

### useEffect 中如何使用 async/await

### 为什么不能在表达式里面定义 react hooks

### 关于 React hooks 的 caputre value，以下输出多少

### 在 redux 中如何发送请求

### 在 redux 中如何写一个记录状态变更的日志插件

### React 在 setState 时发生了什么

### React.setState 是同步还是异步的

### React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的

### 在 React 中如何实现代码分割 (code splitting

### 在 React 中如何做好性能优化

### 当多次重复点击按钮时，以下三个 Heading 是如何渲染的

### React 中什么是合成事件

### React 中监听 input 的 onChange 事件的原生事件是什么

### React.memo 中是如何实现性能优化的

### useLayoutEffect 和 useEffect 有什么区别

## NodeJs

### 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?

在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：

```js
(function(exports, require, module, __filename, __dirname) {
// 模块的代码实际上在这里
});
```

通过这样做，Node 实现了以下几点：

- 保持了顶层变量作用在模块范围内，而不是全局对象
- 有助于提供一些看似全局实际是特定模块的变量：
  - 导出的 `module` 和 `exports`对象
  - 包含模块绝对文件名和目录路径的便捷变量`__filename`和`__dirname`

### a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?

### 说一下NodeJs中的错误处理？

处理错误，最常用的就是try catch 了。可是 try catch无法捕获异步错误。Node.js中，异步操作是十分常见的，异步操作主要是在回调函数中暴露错误。看一个例子：

```js
const readFile = function(path) {
 return new Promise((resolve,reject) => {
  fs.readFile(path, (err, data) => {
   if(err) { 
    throw err; // catch无法捕获错误，这和Node的eventloop有关。
        // reject(err); // catch可以捕获
      }
      resolve(data);
  });
 });
}

router.get('/xxx', async function(req, res) {
  try {
    const res = await readFile('xxx');
    ...
  } catch (e){
    // 捕获错误处理
    ...
    res.send(500);
  }
});
```

上面的代码中，readFile 中 throw 出来的错误，是无法被catch捕获的。如果我们把 throw err 换成 Promise.reject(err)，catch中是可以捕获到错误的。
**我们可以把异步操作都Promise化，然后统一使用 async 、try、catch 来处理错误。**
但是，总会有地方会被遗漏。这个时候，可以使用process来捕获全局错误，防止进程直接退出，导致后面的请求挂掉。示例代码：

```js
process.on('uncaughtException', (err) => {
  console.error(`${err.message}\n${err.stack}`);
});

process.on('unhandledRejection', (reason, p) => {
  console.error(`Unhandled Rejection at: Promise ${p} reason: `, reason);
});

```

### Eventemitter 的 emit 是同步还是异步?

**EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。**

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', () => {
  console.log('hi 1');
});
emitter.on('myEvent', () => {
  console.log('hi 2');
});
emitter.emit('myEvent');
// hi 1
// hi 2
```

如下函数会不会死循环？

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', function sth () {
  emitter.on('myEvent', sth);
  console.log('hi');
});
emitter.emit('myEvent');
// hi
```

不会，只打印一遍hi

### 谈Node中的事件循环及其和浏览器中事件循环的区别？

[掘金：浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.cn/post/6844903761949753352)

### 以下代码，koa 会返回什么数据

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
  wait next()
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 2
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  wait next()
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

### Node如何进行进程间通信？

- 原生IPC通道

```js
// parent.js
const cp = require('child_process');
const n = cp.fork(`child.js`);

n.on('message', (m) => {
  console.log('父进程收到消息', m);
});

// 使子进程输出: 子进程收到消息 { hello: 'world' }
n.send({ hello: 'world' });

// child.js
process.on('message', (m) => {
  console.log('子进程收到消息', m);
});

// 使父进程输出: 父进程收到消息 { foo: 'bar', baz: null }
process.send({ foo: 'bar', baz: NaN });
```

运行：

```code
> node parent.js
子进程收到消息 { hello: 'world' }
父进程收到消息 { foo: 'bar', baz: null }
```

- 通过 sockets
- 消息队列

> 参考：[Node 进程间怎么通信的](https://www.cnblogs.com/everlose/p/12846737.html)

### Node 中 require 时发生了什么？

参考：[详解Node模块加载机制]<https://blog.csdn.net/ayqy_jiajie/article/details/106654770>

### 简述 node/v8 中的垃圾回收机制

### node 中 exec，fork 与 spawn 有何区别？

这四个都可以用来创建子进程

1.spawn和fork都是返回一个基于流的子进程对象

2.exec和execFile可以在回调中拿到返回的buffer的内容（执行成功或失败的输出）

3.exec是创建子shell去执行命令，用来直接执行shell命令  。execFile是去创建任意你指定的文件的进程

4.fork是一种特殊的spawn，可以理解为spawn增强版，返回的子进程对象可以和父进程对象进行通信，通过send和on方法。
> 参考
[Node官网](http://nodejs.cn/api/child_process.html#child_processspawncommand-args-options)

### node 中 dns.resolve 及 dns.lookup 有什么区别

### Node 中 require json 文件数据时，如何当文件更新时，重新 require

```js
function requireUncached(module) {
  delete require.cache[require.resolve(module)];
  return require(module);
}
```

### 在 node 中如何开启 https

```js
import path from "path";
import fs from "fs";
import express from "express";
import http from "http";
import https from "https";

const app = express();

const cred = {
  key: fs.readFileSync(path.resolve(__dirname, "../key.pem")),
  cert: fs.readFileSync(path.resolve(__dirname, "../cert.pem")),
};
const httpServer = http.createServer(app);
const httpsServer = https.createServer(cred, app);

httpServer.listen(8000);
httpsServer.listen(8888);
```

### node 中 module.exports 与 exports 有什么区别

### 在 node 中如何判断一个对象是 stream

`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。

每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`。
代码如下，摘自 is-stream (opens new window): 一个周下载量两千万的 npm package。

```js
const isStream = (stream) =>
  stream !== null &&
  typeof stream === "object" &&
  typeof stream.pipe === "function";

isStream.writable = (stream) =>
  isStream(stream) &&
  stream.writable !== false &&
  typeof stream._write === "function" &&
  typeof stream._writableState === "object";

isStream.readable = (stream) =>
  isStream(stream) &&
  stream.readable !== false &&
  typeof stream._read === "function" &&
  typeof stream._readableState === "object";

isStream.duplex = (stream) =>
  isStream.writable(stream) && isStream.readable(stream);

isStream.transform = (stream) =>
  isStream.duplex(stream) &&
  typeof stream._transform === "function" &&
  typeof stream._transformState === "object";
```

### express 中间件的原理是什么?

一个管道，每一个中间件都是handler，经过每一步处理，最终结束。

### 简述 koa 的中间件原理，手写 koa-compose 代码

```js
function compose(middlewares) {
  return (ctx) => {
    const dispatch = (i) => {
      const middleware = middlewares[i];
      if (i === middlewares.length) {
        return;
      }
      return middleware(ctx, () => dispatch(i + 1));
    };
    return dispatch(0);
  };
}
```

### koa与express的区别？

[glory-Koa与Express的区别](https://zhuanlan.zhihu.com/p/353109449)
[进军的蜗牛-express和koa的区别](https://www.cnblogs.com/yalong/p/15566133.html)

### koa的中间件怎么传递消息？

参数挂到 ctx上

### 在 Node 中流 (stream) 分为几类，有哪些应用场景

Node.js 中有四种基本的流类型：

- Writable: 可以写入数据的流（例如，fs.createWriteStream()）。

- Readable: 可以从中读取数据的流（例如，fs.createReadStream()）。

- Duplex: Readable 和 Writable 的流（例如，net.Socket）。

- Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，zlib.createDeflate()）

### node和客户端怎么解决跨域的问题？

### ESModule 和 CommonJs区别是什么？

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## 网络

### 简单讲解一下http2的多路复用

### 谈谈你对TCP三次握手和四次挥手的理解

### 介绍 HTTPS 握手过程

### HTTPS 握手过程中，客户端如何验证证书的合法性

### 介绍下 HTTPS 中间人攻击

### 介绍下 http1.0、1.1、2.0 协议的区别？

### 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

### 为什么 HTTP1.1 不能实现多路复用（腾讯）

### 介绍下Options请求

## 浏览器

### 从浏览器地址栏输入 url 到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
强缓存。
协商缓存。
2. DNS 域名解析。（字节面试被虐后，是时候搞懂 DNS 了）
3. TCP 连接。

  >总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

4. http 请求。
5. 服务器处理请求并返回 HTTP 报文。
6. 浏览器渲染页面。
推荐阅读：

- [从 URL 输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)
- [从输入 URL 开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)
- [字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)

### 说说浏览器和 Node 事件循环的区别

### 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

### cookie 和 token 都存放在 header 中，为什么不会劫持 token？

### 浏览器缓存读取规则

### 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

### 介绍下如何实现 token 加密

### 介绍下常见的web攻击方式

### 网站开发中，如何实现图片的懒加载

### prefetch 与 preload 的区别是什么

### 简单介绍 requestIdleCallback 及使用场景

### 如何找到当前页面出现次数最多的 HTML 标签

### 浏览器的剪切板中如何监听复制事件

### JSONP 的原理是什么，如何实现

### 如何实现页面文本不可复制

### 异步加载 JS 脚本时，async 与 defer 有何区别

### load 事件与 DomContentLoaded 事件的先后顺序

### React/Vue 中的 router 实现原理如何

### 什么是事件委托，e.currentTarget 与 e.target 有何区别

### SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的

### 简述下 WebWorker，它如何进行通信

### 浏览器中监听事件函数 addEventListener 第三个参数有那些值

### 浏览器中 Frame 与 Event Loop 的关系是什么

### 浏览器中如何使用原生的 ESM

## 设计模式

### 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

## 工程化

### 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？

### 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

### webpack 打包 vue 速度太慢怎么办？

### webpack 中 loader 和 plugin 的区别是什么（平安）

### babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？

### 使用 webpack 时如何优化项目体积

### Tree Shaking 的原理是什么

### vue-loader 的实现原理是什么

### 对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？

### Code Splitting 的原理是什么

### 使用 webpack 如何分包

### 如何压缩前端项目中 JS 的体积

### webpack 的 runtime 做了什么事情

### webpack 中的 code spliting 是如何动态加载 chunk 的？

### 打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中

### 打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源

### 打包器(webpack/rollup) 如何加载 style 样式资源

### 如何提升 webpack 构建资源的速度

### 如何分析前端打包体积

### peerDependency 是为了解决什么问题

### 前端打包时 cjs、es、umd 模块有何不同
