---
title: "2022最新前端面试题整理"
date: 2022-06-06T17:09:23+08:00
---


## HTML

### 如何理解 HTML 语义化？

- 让人更容易读懂（增加代码可读性）。
- 让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。
- 在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。

### script 标签中 defer 和 async 的区别？

- script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- async script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- defer script：完全不会阻碍 HTML

推荐文章 [图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

## CSS

### 盒模型介绍

CSS3 中的盒模型有以下两种：标准盒模型、IE（替代）盒模型。

两种盒子模型都是由 content + padding + border + margin 构成，其大小都是由 content + padding + border 决定的，但是盒子内容宽/高度（即 width/height）的计算范围根据盒模型的不同会有所不同：

- 标准盒模型：只包含 content 。
- IE（替代）盒模型：content + padding + border 。

可以通过 box-sizing 来改变元素的盒模型：

- box-sizing: content-box ：标准盒模型（默认值）。
- box-sizing: border-box ：IE（替代）盒模型。

### 介绍下 BFC 及其应用

BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到**尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸**等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做视觉格式化模型的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，**用于决定块级盒的布局及浮动相互影响范围的一个区域。**
BFC 具有一些特性：

- 块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。
- 在 BFC 中上下相邻的两个容器的 `margin` 会重叠，创建新的 BFC 可以避免外边距重叠。
- 计算 BFC 的高度时，需要计算浮动元素的高度。
- BFC 区域不会与浮动的容器发生重叠。
- BFC 是独立的容器，容器内部元素不会影响外部元素。
- 每个元素的左 `margin` 值和容器的左 `border` 相接触。

利用这些特性，我们可以解决以下问题：

- 利用 4  和 6 ，我们可以实现三栏（或两栏）自适应布局。
- 利用 2 ，我们可以避免 `margin` 重叠问题。
- 利用 3 ，我们可以避免高度塌陷。

创建 BFC 的方式：

- 绝对定位元素（`position` 为 `absolute` 或 `fixed` ）。
- 行内块元素，即 `display` 为 `inline-block` 。
- `overflow` 的值不为 `visible` 。

### 怎么让一个 div 水平垂直居中

### 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

- 结构： display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击

- 继承： display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。 visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。

- 性能： displaynone : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 visibility:hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 opacity: 0 ： 修改元素会造成重绘，性能消耗较少

- 联系：它们都能让元素不可见

### css 如何实现左侧固定 200px，右侧自适应的布局（两栏布局）

现有以下DOM结构

```html
<div class="outer">
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```

1. 利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 margin-left 设为固定宽度 。注意，因为右边元素的 width 默认为 auto ，所以会自动撑满父元素。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  margin-left: 200px;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：浮动+margin-lefts](https://codepen.io/afishtail/pen/jOZJPKJ)

2. 同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 overflow: hidden; 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。

```css
.outer {
  height: 100px;
}
.left {
  float: left;
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  overflow: auto;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：浮动+BFC](https://codepen.io/afishtail/pen/jOZJPKJ)

3. 利用 flex 布局，左边元素固定宽度，右边的元素设置 flex: 1 。

```css
.outer {
  display: flex;
  height: 100px;
}
.left {
  width: 200px;
  height: 100%;
  background: lightcoral;
}
.right {
  flex: 1;
  height: 100%;
  background: lightseagreen;
}
```

[两栏布局实现：flex](https://codepen.io/afishtail/pen/PoQLqVB)
4. grid
5. 绝对定位

### 实现圣杯布局和双飞翼布局（经典三分栏布局）

- grid

``` html
<!-- html -->
<div class="grid-box">
  <div class="grid-item header">
    <div>header</div>
  </div>
  <div class="grid-item left">
    <div>left</div>
  </div>
  <div class="grid-item content">
    <div>content</div>
  </div>
  <div class="grid-item right">
    <div>right</div>
  </div>
  <div class="grid-item footer">
    <div>footer</div>
  </div>
</div>

<!-- css -->
// 第一种 使用grid-template-areas定义
<style>
  .grid-box {
    display: grid;
    grid-template-columns: 200px 1fr 200px;
    grid-auto-rows: 80px 1fr 100px;
    height: 480px;
    border: 1px solid;
    // width: 240px;
    /* 自定义布局格式 */
    grid-template-areas:
      'header header header'
      'left content right'
      'footer footer footer';
  }
  .grid-item {
    border: 1px solid;
    background-color: goldenrod;
  }
  .header {
    /* 使用grid最外层定义的名称 */
    grid-area: header;
    background-color: skyblue;
  }
  .footer {
    background-color: aqua;
    grid-area: footer;
  }
</style>


// 第二种 直接使用数字进行划分
<style>
.grid-box {
  display: grid;
  grid-template-columns: 200px 1fr 200px;
  grid-auto-rows: 80px 1fr 100px;
  height: 480px;
  border: 1px solid;

  .grid-item {
    border: 1px solid;
    background-color: goldenrod;
  }
  .header {
    /* 使用 数字+/ 划分区域 */
    grid-area: 1/1/1/4;
    background-color: skyblue;
  }
  .footer {
    background-color: aqua;
    grid-area: 3/1/3/4;
  }
}
</style>
```

[Grid实现经典双飞翼布局](https://codepen.io/afishtail/pen/oNEVXRe)

- flex
- float + margin负值（感觉代码很繁琐）

### 伪类与伪元素有什么区别

### css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分

### CSS 如何设置一行超出显示省略号

### CSS 如何设置多行超出显示省略号

## JavaScript

### 手写深拷贝

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */

function deepClone(obj = {}, map = new Map()) {
  if (typeof obj !== "object") {
    return obj;
  }
  if (map.get(obj)) {
    return map.get(obj);
  }

  let result = {};
  // 初始化返回结果
  if (
    obj instanceof Array ||
    // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
    Object.prototype.toString(obj) === "[object Array]"
  ) {
    result = [];
  }
  // 防止循环引用
  map.set(obj, result);
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map);
    }
  }

  // 返回结果
  return result;
}
```

### 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？

> 推荐阅读：[硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准](https://juejin.cn/post/6940405970954616839),[0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？](https://juejin.cn/post/6844903680362151950)

原因总结:

- 进制转换 ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。
- 对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。

解决办法：

- 大数运算
- `Number.EPSILON`误差范围

```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

- 转成字符串，对字符串做加法运算。

```js
// 字符串数字相加
var addStrings = function (num1, num2) {
  let i = num1.length - 1;
  let j = num2.length - 1;
  const res = [];
  let carry = 0;
  while (i >= 0 || j >= 0) {
    const n1 = i >= 0 ? Number(num1[i]) : 0;
    const n2 = j >= 0 ? Number(num2[j]) : 0;
    const sum = n1 + n2 + carry;
    res.unshift(sum % 10);
    carry = Math.floor(sum / 10);
    i--;
    j--;
  }
  if (carry) {
    res.unshift(carry);
  }
  return res.join("");
};

function isEqual(a, b, sum) {
  const [intStr1, deciStr1] = a.toString().split(".");
  const [intStr2, deciStr2] = b.toString().split(".");
  const inteSum = addStrings(intStr1, intStr2); // 获取整数相加部分
  const deciSum = addStrings(deciStr1, deciStr2); // 获取小数相加部分
  return inteSum + "." + deciSum === String(sum);
}

console.log(isEqual(0.1, 0.2, 0.3)); // true
```

这是 leetcode 上一道原题：[415. 字符串相加](https://link.juejin.cn/?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-strings%2F)。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。

### 基本的数据类型介绍，及值类型和引用类型的理解

### JS进阶概念

- 原型和原型连
- 作用域与作用域链
- 执行上下文
- 闭包
- 垃圾回收

### call、apply、bind实现

```js
Function.prototype.myCall = function (context) {
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  context.fn = this
  const args = [...arguments].slice(1)
  const res = context.fn(...args)
  delete context.fn
  return res
}

Function.prototype.myApply = function (context) {
  if (typeof context === 'undefined' || context === null) {
    context = window
  }
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}

//TODO： bind手写较难
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
      throw new TypeError('Error')
  }
  //返回一个绑定this的函数，这里我们需要保存this
  const _this = this
  const args = [...arguments].slice(1)
      //返回一个函数
  return function F() {
      //因为返回一个函数，我们可以new F()需要判断能当做构造函数吗
      if (this instanceof F) {
          return new _this(...args, ...arguments)
      }
      return _this.apply(context, args.concat(...arguments))
  }
}
```

### new实现

```js
function myNew(context) {
  const obj = new Object()
  obj.__proto__ = context.prototype
  const res = context.apply(obj, [...arguments].slice(1))
  return typeof res === 'object' ? res: obj
}
```

### 模拟实现一个 Promise.finally

```js
Promise.prototype.fainally = function (callback) {
  let P = this.constructor
  return this.then(
    data => P.resolve(callback()).then(data => data), 
    reason => P.resolve(callback()).then(() => reason)
  )
}
```

### 模拟实现一个 Promise.all

```js
Promise.all = function (promises) {
  return new Promise((resolve, reject) => {
    // 参数可以不是数组，但必须具有 Iterator 接口
    if (typeof promises[Symbol.iterator] !== "function") {
      reject("Type error");
    }
    if (promises.length === 0) {
      resolve([]);
    } else {
      const res = [];
      let count = 0;
      const len = promises.length;
      for (let i = 0; i < len; i++) {
        //考虑到 promises[i] 可能是 thenable 对象也可能是普通值
        Promise.resolve(promises[i])
          .then((data) => {
            res[i] = data;
            if (++count === len) {
              resolve(res);
            }
          })
          .catch((err) => {
            reject(err);
          });
      }
    }
  });
};
```

### 实现一个 EventMitter 类

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }
  // 实现订阅
  on(type, callBack) {
    if (!this.events[type]) {
      this.events[type] = [callBack];
    } else {
      this.events[type].push(callBack);
    }
  }
  // 删除订阅
  off(type, callBack) {
    if (!this.events[type]) return;
    this.events[type] = this.events[type].filter((item) => {
      return item !== callBack;
    });
  }
  // 只执行一次订阅事件
  once(type, callBack) {
    function fn() {
      callBack();
      this.off(type, fn);
    }
    this.on(type, fn);
  }
  // 触发事件
  emit(type, ...rest) {
    this.events[type] &&
      this.events[type].forEach((fn) => fn.apply(this, rest));
  }
}
```

### JS 异步解决方案的发展历程以及优缺点

1. 回调函数
2. Generator
3. Promise
4. async/await

推荐阅读：[JS异步解决方案的发展历程以及优缺点](https://github.com/sisterAn/blog/issues/29)

### 异步笔试题，请写出下面代码的运行结果

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

### 模拟实现一个 Promise.race

```js
Promise._race = promises => new Promise((resolve, reject) => {
 promises.forEach(promise => {
  promise.then(resolve, reject)
 })
})

// 兼容非promise
const _race = (p)=>{
 return new Promise((resolve, reject)=>{
  p.forEach((item)=>{
   Promise.resolve(item).then(resolve, reject)
  })
 })
}
```

## Vue

### 谈一下Vue响应式原理

- 怎么进行依赖收集的？
  在`getter`中收集依赖，getter在  时候触发。

### vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进

### react 与 vue 数组中 key 的作用是什么

diff 算法需要比对虚拟 dom 的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode 会首先判断 key 和标签名是否一致，如果一致再去判断子节点一致，使用 key 可以帮助 diff 算法提升判断的速度，在页面重新渲染时更快消耗更少

### vue 中 computed 的原理是什么

### vue 中 v-if 和 v-show 的区别是什么

### Vue 中 nextTick 的实现原理是什么

### 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？

**（1）hash 模式的实现原理**
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：
<https://www.word.com#search>
复制代码hash  路由模式的实现主要是基于下面几个特性：

- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

**（2）history 模式的实现原理**
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
复制代码history 路由模式的实现主要基于存在下面几个特性：

- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
- 我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。

### 谈谈你对 keep-alive 的了解？

### Vue 组件间通信有哪几种方式？

vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信

### Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法

### 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？

- 这是因为devtool工具会记录mutation的日记;
- 每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照;
- 但是在mutation中执行异步操作，就无法追踪到数据的变化;
- 所以Vuex的重要原则中要求 mutation必须是同步函数;

### 在 Vue 中，子组件为何不可以修改父组件传递的 Prop

### Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

### vue 渲染大量数据时应该怎么优化？

### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？

### vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法

### v-if、v-show、v-html 的原理是什么，它是如何封装的？

## React

### redux 为什么要把 reducer 设计成纯函数

### react-router 里的 <Link> 标签和 <a> 标签有什么区别

### 了解 React 中的 ErrorBoundary 吗，它有那些使用场景

### 有没有使用过 react hooks，它带来了那些便利

### 如何使用 react hooks 实现一个计数器的组件

### React 中，cloneElement 与 createElement 各是什么，有什么区别

### React Portal 有哪些使用场景

### 什么是 virtual DOM，它的引入带了什么好处

### React 中 fiber 是用来做什么的

关于这块儿我觉得可以好好阅读下这篇无敌的博客了：[Build your own React](https://link.juejin.cn/?target=https%3A%2F%2Fpomb.us%2Fbuild-your-own-react%2F)。
它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。
然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章：
[这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.cn/post/6844903975112671239)

### React hooks 中 useCallback 的使用场景是什么

### useEffect 中如何使用 async/await

### 为什么不能在表达式里面定义 react hooks

推荐这篇文章：[我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁](我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁)。

hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。

### 关于 React hooks 的 caputre value，以下输出多少

### 在 redux 中如何发送请求

### 在 redux 中如何写一个记录状态变更的日志插件

### React 在 setState 时发生了什么

### React.setState 是同步还是异步的

`setState` 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。
同步还是异步取决于它被调用的环境。

- 如果 `setState` 在 React 能够控制的范围被调用，它就是异步的。比如合成事件处理函数，生命周期函数， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。
- 如果 `setState` 在原生 JavaScript 控制的范围被调用，它就是同步的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 `setState` 被调用后会立即更新 DOM 。

### React 中的 dom diff 算法如何从 O(n3) 优化到 O(n) 的

### 在 React 中如何实现代码分割 (code splitting

### 在 React 中如何做好性能优化

### 当多次重复点击按钮时，以下三个 Heading 是如何渲染的

### React 中什么是合成事件

### React 中监听 input 的 onChange 事件的原生事件是什么

### React.memo 中是如何实现性能优化的

### useLayoutEffect 和 useEffect 有什么区别

对于 React 的函数组件来说，其更新过程大致分为以下步骤：

1. 因为某个事件 state 发生变化。
2. React 内部更新 state 变量。
3. React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。
4. 将更新过后的 DOM 数据绘制到浏览器中。
5. 用户看到新的页面。

useEffect 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。
useLayoutEffect 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。

### React 事件机制，React 16 和 React 17 事件机制的不同

阅读这篇文章即可：[一文吃透 react 事件系统原理](https://juejin.cn/post/6955636911214067720)。

为什么要自定义事件机制？

抹平浏览器差异，实现更好的跨平台。
避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。
方便事件统一管理和事务机制。

### HOC 和 hook 的区别

hoc 能复用逻辑和视图，hook 只能复用逻辑。

### useEffect 依赖为空数组与 componentDidMount 区别

在 `render` 执行之后，`componentDidMount` 会执行，如果在这个生命周期中再一次 `setState` ，会导致再次 `render` ，返回了新的值，浏览器只会渲染第二次 `render` 返回的值，这样可以避免闪屏。
但是 `useEffect` 是在真实的 `DOM` 渲染之后才会去执行，这会造成两次 `render` ，有可能会闪屏。
实际上 `useLayoutEffect` 会更接近 `componentDidMount` 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。

### React.memo() 和 React.useMemo() 的区别

- `memo` 是一个高阶组件，默认情况下会对 `props` 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。
- `useMemo` 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，`useMemo` 是在 `render` 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。

### React.useCallback() 和 React.useMemo() 的区别

- `useCallback` 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。
- `useMemo` 可缓存值。

有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。

### React.forwardRef 是什么及其作用

这里还是阅读官方文档来的清晰：[React.forwardRef](https://link.juejin.cn/?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-api.html%23reactforwardref)。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。

### React性能优化手段

推荐文章：[React 性能优化的 8 种方式了解一下？](https://juejin.cn/post/6844903924302888973)

- 使用 React.memo 来缓存组件。
- 使用 React.useMemo 缓存大量的计算。
- 避免使用匿名函数。
- 利用 React.lazy 和 React.Suspense 延迟加载不是立即需要的组件。
- 尽量使用 CSS 而不是强制加载和卸载组件。
- 使用 React.Fragment 避免添加额外的 DOM。

### React Redux

[Redux 包教包会（一）：介绍 Redux 三大核心概念](https://juejin.cn/post/6844904021187117069)

## NodeJs

### 如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111 能否在 a 中直接打印出来?

在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：

```js
(function(exports, require, module, __filename, __dirname) {
// 模块的代码实际上在这里
});
```

通过这样做，Node 实现了以下几点：

- 保持了顶层变量作用在模块范围内，而不是全局对象
- 有助于提供一些看似全局实际是特定模块的变量：
  - 导出的 `module` 和 `exports`对象
  - 包含模块绝对文件名和目录路径的便捷变量`__filename`和`__dirname`

### a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题?

### 说一下NodeJs中的错误处理？

处理错误，最常用的就是try catch 了。可是 try catch无法捕获异步错误。Node.js中，异步操作是十分常见的，异步操作主要是在回调函数中暴露错误。看一个例子：

```js
const readFile = function(path) {
 return new Promise((resolve,reject) => {
  fs.readFile(path, (err, data) => {
   if(err) { 
    throw err; // catch无法捕获错误，这和Node的eventloop有关。
        // reject(err); // catch可以捕获
      }
      resolve(data);
  });
 });
}

router.get('/xxx', async function(req, res) {
  try {
    const res = await readFile('xxx');
    ...
  } catch (e){
    // 捕获错误处理
    ...
    res.send(500);
  }
});
```

上面的代码中，readFile 中 throw 出来的错误，是无法被catch捕获的。如果我们把 throw err 换成 Promise.reject(err)，catch中是可以捕获到错误的。
**我们可以把异步操作都Promise化，然后统一使用 async 、try、catch 来处理错误。**
但是，总会有地方会被遗漏。这个时候，可以使用process来捕获全局错误，防止进程直接退出，导致后面的请求挂掉。示例代码：

```js
process.on('uncaughtException', (err) => {
  console.error(`${err.message}\n${err.stack}`);
});

process.on('unhandledRejection', (reason, p) => {
  console.error(`Unhandled Rejection at: Promise ${p} reason: `, reason);
});

```

### Eventemitter 的 emit 是同步还是异步?

**EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。**

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', () => {
  console.log('hi 1');
});
emitter.on('myEvent', () => {
  console.log('hi 2');
});
emitter.emit('myEvent');
// hi 1
// hi 2
```

如下函数会不会死循环？

```js
const EventEmitter = require('events');
let emitter = new EventEmitter();
emitter.on('myEvent', function sth () {
  emitter.on('myEvent', sth);
  console.log('hi');
});
emitter.emit('myEvent');
// hi
```

不会，只打印一遍hi

### 谈Node中的事件循环及其和浏览器中事件循环的区别？

[掘金：浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.cn/post/6844903761949753352)

### 以下代码，koa 会返回什么数据

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  ctx.body = "hello, 1";
  wait next()
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 2
```

```js
const Koa = require("koa");
const app = new Koa();

app.use(async (ctx, next) => {
  wait next()
  ctx.body = "hello, 1";
});

app.use((ctx) => {
  ctx.body = "hello, 2";
});

app.listen(3000);
// hello, 1
```

### Node如何进行进程间通信？

- 原生IPC通道

```js
// parent.js
const cp = require('child_process');
const n = cp.fork(`child.js`);

n.on('message', (m) => {
  console.log('父进程收到消息', m);
});

// 使子进程输出: 子进程收到消息 { hello: 'world' }
n.send({ hello: 'world' });

// child.js
process.on('message', (m) => {
  console.log('子进程收到消息', m);
});

// 使父进程输出: 父进程收到消息 { foo: 'bar', baz: null }
process.send({ foo: 'bar', baz: NaN });
```

运行：

```code
> node parent.js
子进程收到消息 { hello: 'world' }
父进程收到消息 { foo: 'bar', baz: null }
```

- 通过 sockets
- 消息队列

> 参考：[Node 进程间怎么通信的](https://www.cnblogs.com/everlose/p/12846737.html)

### Node 中 require 时发生了什么？

参考：[详解Node模块加载机制]<https://blog.csdn.net/ayqy_jiajie/article/details/106654770>

### 简述 node/v8 中的垃圾回收机制

### node 中 exec，fork 与 spawn 有何区别？

这四个都可以用来创建子进程

1.spawn和fork都是返回一个基于流的子进程对象

2.exec和execFile可以在回调中拿到返回的buffer的内容（执行成功或失败的输出）

3.exec是创建子shell去执行命令，用来直接执行shell命令  。execFile是去创建任意你指定的文件的进程

4.fork是一种特殊的spawn，可以理解为spawn增强版，返回的子进程对象可以和父进程对象进行通信，通过send和on方法。
> 参考
[Node官网](http://nodejs.cn/api/child_process.html#child_processspawncommand-args-options)

### node 中 dns.resolve 及 dns.lookup 有什么区别

### Node 中 require json 文件数据时，如何当文件更新时，重新 require

```js
function requireUncached(module) {
  delete require.cache[require.resolve(module)];
  return require(module);
}
```

### 在 node 中如何开启 https

```js
import path from "path";
import fs from "fs";
import express from "express";
import http from "http";
import https from "https";

const app = express();

const cred = {
  key: fs.readFileSync(path.resolve(__dirname, "../key.pem")),
  cert: fs.readFileSync(path.resolve(__dirname, "../cert.pem")),
};
const httpServer = http.createServer(app);
const httpsServer = https.createServer(cred, app);

httpServer.listen(8000);
httpsServer.listen(8888);
```

### node 中 module.exports 与 exports 有什么区别

### 在 node 中如何判断一个对象是 stream

`stream` 可以通过缓冲区来高效利用内存，从而提高性能。常用场景如读写大文件、http-server 中的大静态文件渲染。

每一个 stream 都有 `pipe` 函数，可以用来判断一个对象是否 `stream`。
代码如下，摘自 is-stream (opens new window): 一个周下载量两千万的 npm package。

```js
const isStream = (stream) =>
  stream !== null &&
  typeof stream === "object" &&
  typeof stream.pipe === "function";

isStream.writable = (stream) =>
  isStream(stream) &&
  stream.writable !== false &&
  typeof stream._write === "function" &&
  typeof stream._writableState === "object";

isStream.readable = (stream) =>
  isStream(stream) &&
  stream.readable !== false &&
  typeof stream._read === "function" &&
  typeof stream._readableState === "object";

isStream.duplex = (stream) =>
  isStream.writable(stream) && isStream.readable(stream);

isStream.transform = (stream) =>
  isStream.duplex(stream) &&
  typeof stream._transform === "function" &&
  typeof stream._transformState === "object";
```

### express 中间件的原理是什么?

一个管道，每一个中间件都是handler，经过每一步处理，最终结束。

### 简述 koa 的中间件原理，手写 koa-compose 代码

```js
function compose(middlewares) {
  return (ctx) => {
    const dispatch = (i) => {
      const middleware = middlewares[i];
      if (i === middlewares.length) {
        return;
      }
      return middleware(ctx, () => dispatch(i + 1));
    };
    return dispatch(0);
  };
}
```

### koa与express的区别？

[glory-Koa与Express的区别](https://zhuanlan.zhihu.com/p/353109449)
[进军的蜗牛-express和koa的区别](https://www.cnblogs.com/yalong/p/15566133.html)

### koa的中间件怎么传递消息？

参数挂到 ctx上

### 在 Node 中流 (stream) 分为几类，有哪些应用场景

Node.js 中有四种基本的流类型：

- Writable: 可以写入数据的流（例如，fs.createWriteStream()）。

- Readable: 可以从中读取数据的流（例如，fs.createReadStream()）。

- Duplex: Readable 和 Writable 的流（例如，net.Socket）。

- Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，zlib.createDeflate()）

### node和客户端怎么解决跨域的问题？

### ESModule 和 CommonJs区别是什么？

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## TypeScript

### 什么是类型保护

- typeof
- 平等缩小(比如===、!==)
- instanceof
- in

### interface和type区别

- 如果是定义**非对象类型**，通常推荐使用type，比如Direction、Alignment、一些Function;
- 如果是定义**对象类型**，那么他们是有区别的:
  - interface 可以重复的对某个接口来定义属性和方法;
  - 而type定义的是别名，别名是不能重复的;

## 网络

### 简单讲解一下http2的多路复用

在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。
HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### 谈谈你对TCP三次握手和四次挥手的理解

推荐阅读：[通俗易懂理解TCP协议三次握手和四次挥手及其常见问题](https://blog.csdn.net/impact_factor/article/details/119394391)

### 介绍 HTTPS 握手过程

1. 客户端使用https的url访问web服务器,要求与服务器建立ssl连接
2. web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥
4. 客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥
5. 之后服务器与客户端使用秘钥加密传输

### HTTPS 握手过程中，客户端如何验证证书的合法性

### 介绍下 HTTPS 中间人攻击

中间人攻击过程如下：

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器。
5. 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密hash值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息
防范方法：

服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

### 介绍下 http1.0、1.1、2.0 协议的区别？

#### HTTP/0.9

已过时。只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。

#### HTTP/1.0

这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。

#### HTTP/1.1

持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1相较于HTTP/1.0协议的区别主要体现在： 缓存处理 带宽优化及网络连接的使用 错误通知的管理 消息在网络中的发送 互联网地址的维护 安全性及完整性

#### HTTP/2

在 HTTP/2 的第一版草案（对 SPDY 协议的复刻）中，新增的性能改进不仅包括HTTP/1.1中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法[HPACK][15](16)。此外， HTTP/2 采用了二进制而非明文来打包、传输客户端—服务器间的数据。[12]

##### 帧、消息、流和TCP连接

有别于HTTP/1.1在连接中的明文请求，HTTP/2与SPDY一样，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。[12]这也是HTTP/1.1与HTTP/2最大的区别所在。 HTTP/2中，每个用户的操作行为被分配了一个流编号(stream ID)，这意味着用户与服务端之间创建了一个TCP通道；协议将每个请求分割为二进制的控制帧与数据帧部分，以便解析。这个举措在SPDY中的实践表明，相比HTTP/1.1，新页面加载可以加快11.81% 到 47.7%[17]

##### HPACK 算法

HPACK算法是新引入HTTP/2的一个算法，用于对HTTP头部做压缩。其原理在于：

客户端与服务端根据 RFC 7541 的附录A，维护一份共同的静态字典（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码； 客户端和服务端根据先入先出的原则，维护一份可动态添加内容的共同动态字典（Dynamic Table）； 客户端和服务端根据 RFC 7541 的附录B，支持基于该静态哈夫曼码表的哈夫曼编码（Huffman Coding）。

##### 服务器推送

网站为了使请求数减少，通常采用对页面上的图片、脚本进行极简化处理。但是，这一举措十分不方便，也不高效，依然需要诸多HTTP链接来加载页面和页面资源。

HTTP/2引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。

### 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

1. 301 redirect——301代表永久性转移(Permanently Moved)，301重定向是网页更改地址后对搜索引擎友好的最好方法，只要不是暂时搬移的情况,都建议使用301来做转址。 如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的PageRank等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零

2. 302 redirect——302代表暂时性转移(Temporarily Moved )，在前些年，不少Black Hat SEO曾广泛应用这项技术作弊，目前，各大主要搜索引擎均加强了打击力度，象Google前些年对Business.com以及近来对BMW德国网站的惩罚。即使网站客观上不是spam，也很容易被搜寻引擎容易误判为spam而遭到惩罚。

### 为什么 HTTP1.1 不能实现多路复用（腾讯）

HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 介绍下Options请求

options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。

推荐阅读：[面试官：说说你对options请求的理解](https://zhuanlan.zhihu.com/p/148078956)

## 浏览器

### 从浏览器地址栏输入 url 到请求返回发生了什么

1. 输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。
强缓存。
协商缓存。
2. DNS 域名解析。（字节面试被虐后，是时候搞懂 DNS 了）
3. TCP 连接。

  >总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

4. http 请求。
5. 服务器处理请求并返回 HTTP 报文。
6. 浏览器渲染页面。
推荐阅读：

- [从 URL 输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)
- [从输入 URL 开始建立前端知识体系](https://juejin.cn/post/6935232082482298911)
- [字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)

### 说说浏览器和 Node 事件循环的区别

### 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

### cookie 和 token 都存放在 header 中，为什么不会劫持 token？

### 浏览器缓存读取规则

推荐阅读：[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)

### 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

- 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
- 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
- 跨域友好
- 执行过程无阻塞
- 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
- GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）

### 介绍下如何实现 token 加密

jwt举例

1. 需要一个secret（随机数）
2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次request在header中带上token
4. 后端用同样的算法解密

### 介绍下常见的web攻击方式

推荐阅读：[常见web攻击方法及防御手段总结](https://blog.csdn.net/qappleh/article/details/80485197)

### 网站开发中，如何实现图片的懒加载

推荐阅读[网站开发中，如何实现图片的懒加载](https://q.shanyue.tech/fe/dom/1.html#%E6%96%B9%E6%A1%88%E4%B8%80-%E4%BD%8D%E7%BD%AE%E8%AE%A1%E7%AE%97-%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6-scroll-dataset-api)

### prefetch 与 preload 的区别是什么

1. preload 加载当前路由必需资源，优先级高。一般对于 Bundle Spliting 资源与 Code Spliting 资源做 preload
2. prefetch 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link 做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源

### 简单介绍 requestIdleCallback 及使用场景

**幕后任务协作调度** API (也叫幕后任务 API 或者简单称为 requestIdleCallback() API) 提供了由用户代理决定，在空闲时间自动执行队列任务的能力。
推荐阅读：[Background Tasks API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)

### 如何找到当前页面出现次数最多的 HTML 标签

```js
// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签
const maxBy = (list, keyBy) =>
  list.reduce((x, y) => (keyBy(x) > keyBy(y) ? x : y));

function getFrequentTag() {
  const tags = [...document.querySelectorAll("*")]
    .map((x) => x.tagName)
    .reduce((o, tag) => {
      o[tag] = o[tag] ? o[tag] + 1 : 1;
      return o;
    }, {});
  return maxBy(Object.entries(tags), (tag) => tag[1]);
}
```

### 在浏览器中如何监听剪切板中内容

通过 Clipboard API 可以获取剪切板中内容，但需要获取到 clipboard-read 的权限，以下是关于读取剪贴板内容的代码：

```js
// 是否能够有读取剪贴板的权限
// result.state == "granted" || result.state == "prompt"
const result = await navigator.permissions.query({ name: "clipboard-read" });

// 获取剪贴板内容
const text = await navigator.clipboard.readText();
```

### JSONP 的原理是什么，如何实现

### 如何实现页面文本不可复制

有 CSS 和 JS 两种方法，以下任选其一或结合使用

使用 CSS 如下：

```css
user-select: none;
```

或使用 JS 如下，监听 selectstart 事件，禁止选中。

当用户选中一片区域时，将触发 selectstart 事件，Selection API 将会选中一片区域。禁止选中区域即可实现页面文本不可复制。

```js
document.body.onselectstart = (e) => {
  e.preventDefault();
};

document.body.oncopy = (e) => {
  e.preventDefault();
};
```

### load 事件与 DomContentLoaded 事件的先后顺序

当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载.

当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件

### React/Vue 中的 router 实现原理如何

前端路由实现的本质是**监听 url 变化**，实现方式有两种：Hash 模式和 History 模式，无需刷新页面就能重新加载相应的页面。 Hash url 的格式为`www.a.com/#/`，当#后的哈希值发生变化时，通过 `hashchange` 事件监听，然后页面跳转。 History url `通过history.pushState和history.replaceState`改变 url。 两种模式的区别：

- hash 只能改变#后的值，而 history 模式可以随意设置同源 url；
- hash 只能添加字符串类的数据，而 history 可以通过 API 添加多种类型的数据；
- hash 的历史记录只显示之前的www.a.com而不会显示 hash 值，而 history 的每条记录都会进入到历史记录；
- hash 无需后端配置且兼容性好，而 history 需要配置index.html用于匹配不到资源的情况。
Author

回答者: shfshanyue(opens new window)

前端路由有两种实现方式:

#### history API

- 通过 history.pushState() 跳转路由
- 通过 popstate event 监听路由变化，但无法监听到 history.pushState() 时的路由变化

#### hash

- 通过 location.hash 跳转路由
- 通过 hashchange event 监听路由变化

### 什么是事件委托，e.currentTarget 与 e.target 有何区别

Event 接口的只读属性 currentTarget 表示的，标识是当事件沿着 DOM 触发时事件的当前目标。它总是指向事件绑定的元素，而 Event.target 则是事件触发的元素。

> 事件委托指当有大量子元素触发事件时，将事件监听器绑定在父元素进行监听，此时数百个事件监听器变为了一个监听器，提升了网页性能。
> 另外，React 把所有事件委托在 Root Element，用以提升性能。

### SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的

> 见文档 [SameSite Cookie - MDN (opens new window)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)见文章 [Cookie 的 SameSite 属性(opens new window)](http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

- None: 任何情况下都会向第三方网站请求发送 Cookie
- Lax: 只有导航到第三方网站的 Get 链接会发送 Cookie，跨域的图片、iframe、form 表单都不会发送 Cookie
- Strict: 任何情况下都不会向第三方网站请求发送 Cookie
目前，主流浏览器 Same-Site 的默认值为 Lax，而在以前是 None，将会预防大部分 CSRF 攻击，如果需要手动指定 Same-Site 为 None，需要指定 Cookie 属性 Secure，即在 https 下发送

### 简述下 WebWorker，它如何进行通信

js 多线程通信，只能访问 navigator、setTimeout 等有限的 api

通过 onmessage 和 postmessage 通信，全局对象是 self

### 浏览器中监听事件函数 addEventListener 第三个参数有那些值

- capture。监听器会在时间捕获阶段传播到 event.target 时触发。
- passive。监听器不会调用 preventDefault()。
- once。监听器只会执行一次，执行后移除。
- singal。调用 abort()移除监听器。

### 浏览器中 Frame 与 Event Loop 的关系是什么

浏览器组成中有两大引擎，JS 引擎和渲染引擎。

Frame(帧)是渲染引擎每隔 16ms(默认 60fps)将渲染树渲染、合成成位图的结果

每次 Event Loop 是 JS 引擎执行的一个周期，执行过程中可能依赖渲染引擎的执行结果，比如访问 DOM 和 CSSOM，也可能影响渲染引擎绘制帧，比如调用 requestAnimationFrame，在每个帧开始绘制时执行一段回调函数(通常包含影响渲染结果的代码)

因此 Frame 和 Event Loop 是相对独立运行的，但是 Event Loop 中执行的代码可能依赖或影响 Frame

### 浏览器中如何使用原生的 ESM

通过 script[type=module]，可直接在浏览器中使用原生 ESM。这也使得前端不打包 (Bundless) 成为可能。
推荐阅读：[浏览器中如何使用原生的 ESM](https://q.shanyue.tech/fe/dom/752.html#importmap)

## 设计模式

### 介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景

## 工程化

> 推荐阅读

- [原理初探：当面试官问 Webpack 的时候他想知道什么](https://juejin.cn/post/6943468761575849992)
- [简易实现：面试官：webpack 原理都不会，手写一个 webpack，看看 AST 怎么用](https://link.juejin.cn/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039231950)
- [加料：简单易懂的 webpack 打包后 JS 的运行过程，Webpack 手写 loader 和 plugin](https://juejin.cn/post/6888936770692448270)
- [热更新原理：Webpack HMR 原理解析](https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F30669007)
- [面试题：「吐血整理」再来一打 Webpack 面试题](https://juejin.cn/post/6844904094281236487)

### 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？

npm install会检测是有package-lock.json文件:

- 没有lock文件
  - 分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况;
  - 从registry仓库中下载压缩包(如果我们设置了镜像，那么会从镜像服务器下载压缩包);
  - 获取到压缩包后会对压缩包进行缓存(从npm5开始有的);
  - 将压缩包解压到项目的node_modules文件夹中(前面我们讲过，require的查找顺序会在该包下面查找)
- 有lock文件
  - 检测lock中包的版本是否和package.json中一致(会按照semver版本规范检测);
    - 不一致，那么会重新构建依赖关系，直接会走顶层的流程;
    - 一致的情况下，会去优先查找缓存
      - 没有找到，会从registry仓库下载，直接走顶层流程;
      - 查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中;

### 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的
推荐阅读： [轻松理解webpack热更新原理](https://juejin.cn/post/6844904008432222215)
 

### webpack 打包 vue 速度太慢怎么办？
1. 使用webpack-bundle-analyzer对项目进行模块分析生成report，查看report后看看哪些模块体积过大，然后针对性优化，比如我项目中引用了常用的UI库element-ui和v-charts等

2. 配置webpack的externals ，官方文档的解释：防止将某些import的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖。 所以，可以将体积大的库分离出来：

```json
// ...
externals: {
    'element-ui': 'Element',
    'v-charts': 'VCharts'
}
```
3. 然后在main.js中移除相关库的import

4. 在index.html模板文件中，添加相关库的cdn引用，如：
```html
<script src="https://unpkg.com/element-ui@2.10.0/lib/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/v-charts/lib/index.min.js"></script>
```
经过以上的处理，再尝试编译打包，会发现速度快了一些。 有什么更好的方式或不对的地方欢迎指出
### webpack 中 loader 和 plugin 的区别是什么（平安）
loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。

plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务

### babel 怎么把字符串解析成 AST，是怎么进行词法/语法分析的？
解析 --> 转换 --> 生成代码
推荐阅读：[[实践系列]Babel原理](https://juejin.cn/post/6844903760603398151)

### 使用 webpack 时如何优化项目体积

### Tree Shaking 的原理是什么
Tree Shaking 指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。

### vue-loader 的实现原理是什么
vue-loader 会把 sfc 中的内容拆分为 template，script，style 三个“虚拟模块”，然后分别匹配 webpack 配置中对应的 rules，比如 script 模块会匹配所有跟处理 JavaScript 或 TypeScript 相关的 loader。

template 中的内容会通过 vue compiler 转换为 render 函数后合并到 script “虚拟模块”中。

scoped style 会经过 vue-loader/style-post-loader 的处理，成为只匹配特定元素的私有样式。

### 对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？

### Code Splitting 的原理是什么

### 使用 webpack 如何分包

### 如何压缩前端项目中 JS 的体积

### webpack 的 runtime 做了什么事情

### webpack 中的 code spliting 是如何动态加载 chunk 的？

### 打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中

### 打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源

### 打包器(webpack/rollup) 如何加载 style 样式资源

### 如何提升 webpack 构建资源的速度

### 如何分析前端打包体积

### peerDependency 是为了解决什么问题

### 前端打包时 cjs、es、umd 模块有何不同

### sourceMap的最佳实践？

- 开发阶段:推荐使用 source-map或者cheap-module-source-map。这分别是vue和react使用的值，可以获取调试信息，方便快速开发;
- 测试阶段:推荐使用 source-map或者cheap-module-source-map。测试阶段我们也希望在浏览器下看到正确的错误提示;
- 发布阶段:false、缺省值(不写)
